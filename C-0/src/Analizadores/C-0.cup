package Analizadores;

import java_cup.runtime.*;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Vector;
import java.io.IOException;
import java.lang.Math;

action code {:

    TablaSimbolos ts;

    int cuentaWhiles;
    int cuentaDirecciones;
    CodigoIntermedio codigoIntermedio;
    String ficheroCodigoIntermedio=null;
    String codFuente;

    int cuentaIf;
    Pila pilaIf;

	//Bloque While
    int cuentaBucle;
    Pila pilaBucle;

	//PUTS
    int cuentaCadenas;
    Lista listaCadenas;


    void inicializar() {
		ts = new TablaSimbolos();
		cuentaWhiles = 0;
		cuentaDirecciones = 9999;
		cuentaIf = 0;
		pilaIf = new Pila();
		cuentaBucle = 0;
		pilaBucle = new Pila();
		cuentaCadenas = 0;
		listaCadenas = new Lista();
                
		String nombre = parser.nombreFichero.substring(0,parser.nombreFichero.lastIndexOf("."));
		codigoIntermedio = new CodigoIntermedio(nombre+".ci");
		try {
			codigoIntermedio.abrirFicheroEscritura();
		} catch (IOException e) {
			System.out.println(Textos.ficheroCiNoExiste);
			codigoIntermedio.cerrarFicheroEscritura();
		}
	}

    boolean existe(String id)
    {
        return ts.existe(id);
    }

    void insertarSimbolo(String id) {
		ts.insertarSimbolo(id);
    }

    void setDireccionSimbolo(String id,int dir)
    {
	ts.setDireccionSimbolo(id,dir);
    }

    Expresion suma(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("SUMAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }

    Expresion resta(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("RESTAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion producto(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("MULTIPLICAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion division(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("DIVIDIR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion entero(String e)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("CARGAR_VALOR",
	e,
	null,
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion identificador(String id)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("CARGAR_DIRECCION",
	String.valueOf((ts.getSimbolo(id)).getDireccion()),
	null,
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }

	//CONDICIÓN OR
	Expresion or(Expresion c1,Expresion c2) {
		cuentaDirecciones++;  
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("OR",
		String.valueOf(c1.getDireccion()),
		String.valueOf(c2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}

	//CONDICIÓN AND
	Expresion and(Expresion c1,Expresion c2) {
		cuentaDirecciones++;
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("AND",
		String.valueOf(c1.getDireccion()),
		String.valueOf(c2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}	

	//MAYOR > 
	Expresion mayor(Expresion e1,Expresion e2) {
		cuentaDirecciones++;
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("MAYOR",
		String.valueOf(e1.getDireccion()),
		String.valueOf(e2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}

	//MENOR <
	Expresion menor(Expresion e1,Expresion e2) {
		cuentaDirecciones++;
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("MENOR",
		String.valueOf(e1.getDireccion()),
		String.valueOf(e2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}

	//IGUAL == 
	Expresion igual(Expresion e1,Expresion e2) {
		cuentaDirecciones++;
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("IGUAL",
		String.valueOf(e1.getDireccion()),
		String.valueOf(e2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}

	//DISTINTO !=
	Expresion distinto(Expresion e1,Expresion e2) {
		cuentaDirecciones++;
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("DISTINTO",
		String.valueOf(e1.getDireccion()),
		String.valueOf(e2.getDireccion()),
		String.valueOf(cuentaDirecciones)));
		return new Expresion(cuentaDirecciones);
	}

	void asignacion(String id,Expresion e) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
		"CARGAR_DIRECCION",
		String.valueOf(e.getDireccion()),null,
		String.valueOf((ts.getSimbolo(id)).getDireccion())));
	}

        void cerrarCI() {
            codigoIntermedio.cerrarFicheroEscritura();
	}

	//METODOS PARA EL CI DE UNA INSTRUCCION IF-THEN-ELSE
	void condicion(Expresion e,int n) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
			"SALTAR_CONDICION",
			String.valueOf(e.getDireccion()),
			null,
			"ELSE_"+String.valueOf(n)));
	} 

	
	void saltarEtiqueta(String eti,int n) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
			"SALTAR_ETIQUETA",
			null,
			null,
			eti+"_"+String.valueOf(n)));
	} 
	
	void ponerEtiqueta(String eti,int n) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
		"ETIQUETA",
		null,
		null,
		eti+"_"+String.valueOf(n)));
	}

	//METODOS PARA EL CI DE UNA INSTRUCCIÓN DE BLOQUE WHILE
	void condicion2(Expresion e,int n) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
			"SALTAR_CONDICION",
			String.valueOf(e.getDireccion()),
			null,
			"FINBLUCLE_"+String.valueOf(n)));
	} 

	//METODO DE CI PARA LAS INSTRUCCIONES PUTW
	void imprimirW(Expresion e) {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
		"IMPRIMIR_ENTERO",
		String.valueOf(e.getDireccion()),
		null,
		null));
	}

	//Método de CI para IMPRIMIR INSTRUCCIONES PUTS (STRINGS)
	void imprimirS(String c,int cuenta){
		listaCadenas.addCadena(c);
		codigoIntermedio.guardarCuadrupla(new Cuadrupla(
		"IMPRIMIR_CADENA",
		"CADENA_"+String.valueOf(cuenta),
		null,
		null));
	}

	void generarCadenas() {
		for(int i=0;i<listaCadenas.size();i++) {
			codigoIntermedio.guardarCuadrupla(new Cuadrupla(
			"PONER_CADENA",
			"CADENA_"+String.valueOf(i+1),
			null,
			listaCadenas.getCadena(i)));
		}
	}

	//Método para cerrar el programa y deje de emitir instrucciones
	void finPrograma() {
		codigoIntermedio.guardarCuadrupla(new Cuadrupla("FIN",null,null,null));
	}

	

:}

parser code {:
	
    static String nombreFichero;

    public void error(String mensaje) {
        System.out.println("ERROR lin:"+InformacionCodigo.linea+
        " tok:"+InformacionCodigo.token+" => "+mensaje);
    }

    public static void main(String args[]) throws Exception {
        if (args.length != 1) {
            System.out.println("Falta fichero");
        } else {
            try {
                Yylex lexico = new Yylex(new FileReader(args[0]));
                String name = (String) args[0];
                codFuente = name.substring(0, name.lastIndexOf("."));
                ficheroCodigoIntermedio = codFuente + ".log";
                inicializar();
                new parser(lexico).parse();
                /*Yylex lexico = new Yylex(new FileReader(args[0]));
                nombreFichero = (String)args[0];
		new parser(lexico).parse();*/
            } catch (FileNotFoundException e1) {
                System.out.println("Fichero no abierto");
            }
        }
    }
    
    public void report_error(String message, Object info) {
        error(message);
    } 
 
    public void syntax_error(Symbol actual) {
        error("Error SINTACTICO");
    } 

    public void report_fatal_error(String message, Object info) {
        error(message);
    } 
 
    public void unrecovered_syntax_error(Symbol actual) {
    } 
:};
//Requerimientos de CUP





//---------------------------------Terminales-------------------------------------------------------------------------

terminal PTOCOMA;
terminal LPAREN;
terminal RPAREN;
terminal PRODUCTO;
terminal SUMA;
terminal DIVISION;
terminal RESTA;
terminal MENOR;
terminal MAYOR;
terminal IGUAL;
terminal DISTINTO;
terminal OR;
terminal AND;
terminal ASIGNAR;
terminal LLLAVE, RLLAVE;

terminal MAIN;
terminal IF;
terminal WHILE;
terminal ELSE;
terminal PUTW;
terminal PUTS;
terminal INT;
terminal BREAK;
terminal NUMERO;

terminal String ID;
terminal String ENTERO;
terminal String CADENATEXTO;

//---------------------------------NO Terminales-------------------------------------------------------------------------

non terminal Programa, Declaraciones, Cuerpo;
non terminal Declaracion;
non terminal BloqueSentencias;
non terminal Sentencias, Sentencia;
non terminal Expresion Expresion;
non terminal Expresion Condicion;
non terminal SentIf, SentElse;
non terminal SentWhile;
non terminal SentAsignacion;
non terminal SentPutw, SentPuts;
non terminal SentBreak;


//Precedencias
precedence left ASIGNAR;
precedence left OR, AND;
precedence left IGUAL, DISTINTO, MAYOR, MENOR;     
precedence left SUMA, RESTA;
precedence left PRODUCTO, DIVISION;
precedence left LPAREN, RPAREN;


//Gramática
start with Programa;  //A

Programa::= {:
			inicializar();
		 :}
                Declaraciones Cuerpo | Cuerpo;  //A

Declaraciones::= Declaracion Declaraciones | Declaracion;

Declaracion ::= INT ID:id PTOCOMA
			{:
    if(existe(id)) {
	parser.error(Textos.simboloRedeclarado);
    } else {
	insertarSimbolo(id);
	cuentaDirecciones++;
	setDireccionSimbolo(id,cuentaDirecciones);
    }:}
		    ;

Cuerpo ::= MAIN LPAREN RPAREN LLLAVE BloqueSentencias
			{:
				finPrograma();
				generarCadenas();
				cerrarCI();
				//generarCF();
			:}
			RLLAVE;

BloqueSentencias::= Sentencias | ;

Sentencias::= Sentencia Sentencias | Sentencia;

Expresion ::= Expresion:e1 SUMA Expresion:e2 
			{:
				RESULT=suma(e1,e2);
			:}
              |
		  Expresion:e1 RESTA Expresion:e2
                        {:
				RESULT=resta(e1,e2);
			:}
			
		  |
              Expresion:e1 PRODUCTO Expresion:e2 
			{:
				RESULT=producto(e1,e2);
			:}
		  |
		  Expresion:e1 DIVISION Expresion:e2 
			{:
				RESULT=division(e1,e2);
			:}
		  |
		  ENTERO:e  
			{:
				RESULT=entero(e);
			:}
		  |
		  ID:id 
			{:
				if(existe(id)) {
					RESULT=identificador(id);
				} else {
					parser.error(Texto.simboloNoDeclarado);
					RESULT=identificador(null);
				}
			:}
		  |
	   	  LPAREN Expresion:e RPAREN 
			{:
				RESULT=e;
			:}
		  ;

Condicion ::= Condicion:c1 OR Condicion:c2 
			{:
			RESULT=or(c1,c2);	
			:}
	        |
		  Condicion:c1 AND Condicion:c2 
			{:
				RESULT=and(c1,c2);
			:}
		  |
      	  Expresion:e1 IGUAL Expresion:e2 
			{:
				RESULT=igual(e1,e2);
			:}
		  |
		  Expresion:e1 DISTINTO Expresion:e2 
			{:
				RESULT=distinto(e1,e2);
			:}
		  |
		  Expresion:e1 MAYOR Expresion:e2 
			{:
				RESULT=mayor(e1,e2);
			:}
		  |
		  Expresion:e1 MENOR Expresion:e2 
			{:
				RESULT=menor(e1,e2);
			:}
		  |
		  LPAREN Condicion:c RPAREN
			{:
				RESULT=c;
			:}
              ;

SentIf ::= IF LPAREN
		{:
			cuentaIf++;
			pilaIf.apilar(cuentaIf);
		:}
			Condicion:c
		{:
                        System.out.println("CONDICION C: " + c);
			condicion(c,pilaIf.verCima());
		:}
			RPAREN LLLAVE BloqueSentencias RLLAVE
		{:
			saltarEtiqueta("FINIF",pilaIf.verCima());
			ponerEtiqueta("ELSE",pilaIf.verCima());
		:}
			SentElse
		{:
			ponerEtiqueta("FINIF",pilaIf.verCima());
			pilaIf.desapilar();
		:}
		;

SentElse ::= ELSE LLLAVE BloqueSentencias RLLAVE |;

SentWhile ::= WHILE LPAREN
		{:
			cuentaBucle++;
			pilaBucle.apilar(cuentaBucle);
			ponerEtiqueta("BUCLE",pilaBucle.verCima());
		:}
			Condicion:c
		{:
			condicion2(c,pilaBucle.verCima());
		:}
			RPAREN LLLAVE
		{:
			cuentaWhiles++;
		:}
			BloqueSentencias
		{:
			cuentaWhiles--;
		:}
			RLLAVE
		{:
			saltarEtiqueta("BUCLE",pilaBucle.verCima());
			ponerEtiqueta("FINBUCLE",pilaBucle.verCima());
			pilaBucle.desapilar();
		:}
		;

SentAsignacion::= ID:id 
                {:
                if(existe(id)) {
		} else {
                    parser.error(Textos.simboloNoDeclarado);
			}
                :}
                ASIGNAR Expresion:e PTOCOMA 
                {:
                    asignacion(id,e);
                :};

SentPutw ::= PUTW LPAREN Expresion:e 
			{:
				imprimirW(e);
			:}
	       RPAREN PTOCOMA;

SentPuts ::= PUTS LPAREN CADENATEXTO:c
			{:
				cuentaCadenas++;
				imprimirS(c,cuentaCadenas);
			:}
			RPAREN PTOCOMA;

SentBreak ::= BREAK 
			{:
			if(cuentaWhiles > 0){
                           }else{
                            parser.error(Texto.breakSinWhile);
                        }       
			:}
		  PTOCOMA;

Sentencia ::= SentIf |
		  SentWhile |
		  SentAsignacion |
		  SentPutw |
		  SentPuts |
		  SentBreak;
