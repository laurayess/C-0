package Analizadores;

import java_cup.runtime.*;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Vector;
import java.io.IOException;
import java.lang.Math;


//Requerimientos de CUP
parser code {:
    static TablaSimbolos ts;
    int cuentaDirecciones;
    static CodigoIntermedio codigoIntermedio;
    static String ficheroCodigoIntermedio=null;
    static String codFuente;

    public void error(String mensaje) {
        System.out.println("ERROR lin:"+InformacionCodigo.linea+
        " tok:"+InformacionCodigo.token+" => "+mensaje);
    }

    /*public static void inicializar() throws IOException {
        ts = new TablaSimbolos();
        codigoIntermedio = new CodigoIntermedio(ficheroCodigoIntermedio);
        codigoIntermedio.abrirFicheroEscritura();
    }*/
    void inicializar() {
		tabla = new Tabla();
		cuentaWhiles = 0;
		cuentaDirecciones = 9999;
		cuentaIf = 0;
		pilaIf = new Pila();
		cuentaBucle = 0;
		pilaBucle = new Pila();
		cuentaCadenas = 0;
		listaCadenas = new Lista();
		String nombre = parser.nombreFichero.substring(0,parser.nombreFichero.lastIndexOf("."));
		codigoIntermedio = new CodigoIntermedio(nombre+".ci");
		try {
			codigoIntermedio.abrirFicheroEscritura();
		} catch (IOException e) {
                System.out.println(Textos.ficheroCiNoExiste);
			codigoIntermedio.cerrarFicheroEscritura();
		}
	}

    public static void main(String args[]) throws Exception {
        if (args.length != 1) {
            System.out.println("Falta fichero");
        } else {
            try {
                /*Yylex lexico = new Yylex(new FileReader(args[0]));
                String name = (String) args[0];
                codFuente = name.substring(0, name.lastIndexOf("."));
                ficheroCodigoIntermedio = codFuente + ".log";
                inicializar();
                new Analizador_Sintactico(lexico).parse();*/
                Yylex lexico = new Yylex(new FileReader(args[0]));
                nombreFichero = (String)args[0];
		new parser(lexico).parse();
            } catch (FileNotFoundException e1) {
                System.out.println("Fichero no abierto");
            }
        }
    }

    void setDireccionSimbolo(String id,int dir)
    {
	tabla.setDireccionSimbolo(id,dir);
    }
    
    Expresion suma(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("SUMAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }

    Expresion resta(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("RESTAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion producto(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("MULTIPLICAR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion division(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("DIVIDIR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion entero(String e)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("CARGAR_VALOR",
	e,
	null,
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion identificador(String id)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("CARGAR_DIRECCION",
	String.valueOf((tabla.getSimbolo(id)).getDireccion()),
	null,
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion or(Expresion c1,Expresion c2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("OR",
	String.valueOf(c1.getDireccion()),
	String.valueOf(c2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion and(Expresion c1,Expresion c2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("AND",
	String.valueOf(c1.getDireccion()),
	String.valueOf(c2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion mayor(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("MAYOR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion menor(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("MENOR",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion igual(Expresion e1,Expresion e2)
    {
	cuentaDirecciones++;
        codigoIntermedio.guardarCuadrupla(new Cuadrupla("IGUAL",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    Expresion distinto(Expresion e1,Expresion e2)
    {
        cuentaDirecciones++;
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("DISTINTO",
	String.valueOf(e1.getDireccion()),
	String.valueOf(e2.getDireccion()),
	String.valueOf(cuentaDirecciones)));
	return new Expresion(cuentaDirecciones);
    }
    
    void asignacion(String id,Expresion e)
    {
	codigoIntermedio.guardarCuadrupla(new Cuadrupla("CARGAR_DIRECCION",
	String.valueOf(e.getDireccion()),
	null,
	String.valueOf((tabla.getSimbolo(id)).getDireccion())));
    }
    public void report_error(String message, Object info) {
        error(message);
    } 
 
    public void syntax_error(Symbol actual) {
        error("Error SINTACTICO");
    } 

    public void report_fatal_error(String message, Object info) {
        error(message);
    } 
 
    public void unrecovered_syntax_error(Symbol actual) {
    } 
:};

//---------------------------------Terminales-------------------------------------------------------------------------

terminal PTOCOMA;
terminal LPAREN;
terminal RPAREN;
terminal PRODUCTO;
terminal SUMA;
terminal DIVISION;
terminal RESTA;
terminal MENOR;
terminal MAYOR;
terminal IGUAL;
terminal DISTINTO;
terminal OR;
terminal AND;
terminal ASIGNAR;
terminal CADENA;
terminal LLLAVE, RLLAVE;

terminal MAIN;
terminal IF;
terminal WHILE;
terminal ELSE;
terminal PUTW;
terminal PUTS;
terminal INT;
terminal BREAK;
terminal NUMERO;

terminal String ID;
terminal String ENTERO;
terminal String CADENATEXTO;

//---------------------------------NO Terminales-------------------------------------------------------------------------

non terminal Programa, Declaraciones, Cuerpo;
non terminal Declaracion;
non terminal BloqueSentencias;
non terminal Sentencias, Sentencia;
non terminal Expresion Expresion;
non terminal Expresion Condicion;
non terminal SentIf, SentElse;
non terminal SentWhile;
non terminal SentAsignacion;
non terminal SentPutw, SentPuts;
non terminal SentBreak;


//Precedencias
precedence left ASIGNAR;
precedence left OR, AND;
precedence left IGUAL, DISTINTO, MAYOR, MENOR;     
precedence left SUMA, RESTA;
precedence left PRODUCTO, DIVISION;
precedence left LPAREN, RPAREN;


//Gram√°tica
start with Programa;  //A

Programa::= Declaraciones Cuerpo | Cuerpo;  //A

Declaraciones::= Declaracion Declaraciones | Declaracion;

Declaracion ::= INT ID:id PTOCOMA
{:
    if(existeSimbolo(id)) {
	parser.error(Textos.simboloRedeclarado);
    } else {
	addSimbolo(id);
	cuentaDirecciones++;
	setDireccionSimbolo(id,cuentaDirecciones);
    }:}
;

Cuerpo ::= MAIN LPAREN RPAREN LLLAVE BloqueSentencias 
{: 
    //finPrograma();
    //generarCadenas();
    cerrarCI(); 
    //generarCF();
:}
RLLAVE;
BloqueSentencias::= Sentencias | ;

Sentencias::= Sentencia Sentencias | Sentencia;


Expresion ::= Expresion:e1 SUMA Expresion:e2 
			{:
				
			:}
              |
		  Expresion:e1 RESTA Expresion:e2 
			{:
				
			:}
		  |
              Expresion:e1 PRODUCTO Expresion:e2 
			{:
				
			:}
		  |
		  Expresion:e1 DIVISION Expresion:e2 
			{:
				
			:}
		  |
		  ENTERO:e 
			{:
				
			:}
		  |
		  ID:id 
			{:
				
			:}
		  |
	   	  LPAREN Expresion:e RPAREN 
			{:
				
			:}
		  ;

Condicion ::= Condicion:c1 OR Condicion:c2 
			{:
				
			:}
	        |
		  Condicion:c1 AND Condicion:c2 
			{:
				
			:}
		  |
      	  Expresion:e1 IGUAL Expresion:e2 
			{:
				
			:}
		  |
		  Expresion:e1 DISTINTO Expresion:e2 
			{:
				
			:}
		  |
		  Expresion:e1 MAYOR Expresion:e2 
			{:
				
			:}
		  |
		  Expresion:e1 MENOR Expresion:e2 
			{:
				
			:}
		  |
		  LPAREN Condicion:c RPAREN
			{:
				
			:}
              ;

SentIf ::= IF LPAREN 
			{:
				
			:}
           Condicion:c 
			{:
				
			:}
	     RPAREN LLLAVE BloqueSentencias RLLAVE 
			{:
				
			:}
	     SentElse
			{:
				
			:}
           ;

SentElse ::= ELSE LLLAVE BloqueSentencias RLLAVE |;

SentWhile ::= WHILE LPAREN 
			{:
				
			:}
		  Condicion:c
			{:
				
			:} 
		  RPAREN LLLAVE 
			{:
				
			:}
		  BloqueSentencias 
			{:
				
			:}
		  RLLAVE
			{:
				
			:}
		  ;

SentAsignacion ::= ID:id
				{:
					
				:} 
			 ASIGNAR Expresion:e PTOCOMA
				{:
					
				:}
                   ;

SentPutw ::= PUTW LPAREN Expresion:e 
			{:
				
			:}
	       RPAREN PTOCOMA;

SentPuts ::= PUTS LPAREN CADENATEXTO:c
			{:
				
			:}
	       RPAREN PTOCOMA;

SentBreak ::= BREAK 
			{:
			
			:}
		  PTOCOMA;

Sentencia ::= SentIf |
		  SentWhile |
		  SentAsignacion |
		  SentPutw |
		  SentPuts |
		  SentBreak;
